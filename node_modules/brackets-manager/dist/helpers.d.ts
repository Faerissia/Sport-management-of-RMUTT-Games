import { GrandFinalType, Match, MatchGame, MatchResults, Participant, ParticipantResult, Result, RoundRobinMode, Seeding, SeedOrdering, Stage, StageType, Status } from 'brackets-model';
import { BracketKind, Database, Duel, FinalStandingsItem, IdMapping, Nullable, OmitId, ParitySplit, ParticipantSlot, Scores, Side } from './types';
/**
 * Splits an array of objects based on their values at a given key.
 *
 * @param objects The array to split.
 * @param key The key of T.
 */
export declare function splitBy<T extends Record<string, unknown>, K extends keyof T, U extends Record<K, string | number>>(objects: U[], key: K): U[][];
/**
 * Splits an array in two parts: one with even indices and the other with odd indices.
 *
 * @param array The array to split.
 */
export declare function splitByParity<T>(array: T[]): ParitySplit<T>;
/**
 * Makes a list of rounds containing the matches of a round-robin group.
 *
 * @param participants The participants to distribute.
 * @param mode The round-robin mode.
 */
export declare function makeRoundRobinMatches<T>(participants: T[], mode?: RoundRobinMode): [T, T][][];
/**
 * Distributes participants in rounds for a round-robin group.
 *
 * Conditions:
 * - Each participant plays each other once.
 * - Each participant plays once in each round.
 *
 * @param participants The participants to distribute.
 */
export declare function makeRoundRobinDistribution<T>(participants: T[]): [T, T][][];
/**
 * A helper to assert our generated round-robin is correct.
 *
 * @param input The input seeding.
 * @param output The resulting distribution of seeds in groups.
 */
export declare function assertRoundRobin(input: number[], output: [number, number][][]): void;
/**
 * Distributes elements in groups of equal size.
 *
 * @param elements A list of elements to distribute in groups.
 * @param groupCount The group count.
 */
export declare function makeGroups<T>(elements: T[], groupCount: number): T[][];
/**
 * Balances BYEs to prevents having BYE against BYE in matches.
 *
 * @param seeding The seeding of the stage.
 * @param participantCount The number of participants in the stage.
 */
export declare function balanceByes(seeding: Seeding, participantCount?: number): Seeding;
/**
 * Normalizes IDs in a database.
 *
 * All IDs (and references to them) are remapped to consecutive IDs starting from 0.
 *
 * @param data Data to normalize.
 */
export declare function normalizeIds(data: Database): Database;
/**
 * Makes a mapping between old IDs and new normalized IDs.
 *
 * @param elements A list of elements with IDs.
 */
export declare function makeNormalizedIdMapping(elements: {
    id: number;
}[]): IdMapping;
/**
 * Apply a normalizing mapping to a participant.
 *
 * @param participant The participant.
 * @param mapping The mapping of IDs.
 */
export declare function normalizeParticipant(participant: ParticipantResult | null, mapping: IdMapping): ParticipantResult | null;
/**
 * Sets the size of an array with a placeholder if the size is bigger.
 *
 * @param array The original array.
 * @param length The new length.
 * @param placeholder A placeholder to use to fill the empty space.
 */
export declare function setArraySize<T>(array: T[], length: number, placeholder: T): T[];
/**
 * Makes pairs with each element and its next one.
 *
 * @example [1, 2, 3, 4] --> [[1, 2], [3, 4]]
 * @param array A list of elements.
 */
export declare function makePairs<T>(array: T[]): [T, T][];
/**
 * Ensures that a list of elements has an even size.
 *
 * @param array A list of elements.
 */
export declare function ensureEvenSized<T>(array: T[]): void;
/**
 * Ensures there are no duplicates in a list of elements.
 *
 * @param array A list of elements.
 */
export declare function ensureNoDuplicates<T>(array: Nullable<T>[]): void;
/**
 * Ensures that two lists of elements have the same size.
 *
 * @param left The first list of elements.
 * @param right The second list of elements.
 */
export declare function ensureEquallySized<T>(left: T[], right: T[]): void;
/**
 * Fixes the seeding by enlarging it if it's not complete.
 *
 * @param seeding The seeding of the stage.
 * @param participantCount The number of participants in the stage.
 */
export declare function fixSeeding(seeding: Seeding, participantCount: number): Seeding;
/**
 * Ensures that the participant count is valid.
 *
 * @param stageType Type of the stage to test.
 * @param participantCount The number to test.
 */
export declare function ensureValidSize(stageType: StageType, participantCount: number): void;
/**
 * Ensures that a match scores aren't tied.
 *
 * @param scores Two numbers which are scores.
 */
export declare function ensureNotTied(scores: [number, number]): void;
/**
 * Converts a TBD to a BYE.
 *
 * @param slot The slot to convert.
 */
export declare function convertTBDtoBYE(slot: ParticipantSlot): ParticipantSlot;
/**
 * Converts a participant slot to a result stored in storage.
 *
 * @param slot A participant slot.
 */
export declare function toResult(slot: ParticipantSlot): ParticipantSlot;
/**
 * Converts a participant slot to a result stored in storage, with the position the participant is coming from.
 *
 * @param slot A participant slot.
 */
export declare function toResultWithPosition(slot: ParticipantSlot): ParticipantSlot;
/**
 * Returns the winner of a match.
 *
 * @param match The match.
 */
export declare function getWinner(match: MatchResults): ParticipantSlot;
/**
 * Returns the loser of a match.
 *
 * @param match The match.
 */
export declare function getLoser(match: MatchResults): ParticipantSlot;
/**
 * Returns the pre-computed winner for a match because of BYEs.
 *
 * @param opponents Two opponents.
 */
export declare function byeWinner(opponents: Duel): ParticipantSlot;
/**
 * Returns the pre-computed winner for a match because of BYEs in a lower bracket.
 *
 * @param opponents Two opponents.
 */
export declare function byeWinnerToGrandFinal(opponents: Duel): ParticipantSlot;
/**
 * Returns the pre-computed loser for a match because of BYEs.
 *
 * Only used for loser bracket.
 *
 * @param opponents Two opponents.
 * @param index The index of the duel in the round.
 */
export declare function byeLoser(opponents: Duel, index: number): ParticipantSlot;
/**
 * Returns the winner side or `null` if no winner.
 *
 * @param match A match's results.
 */
export declare function getMatchResult(match: MatchResults): Side | null;
/**
 * Finds a position in a list of matches.
 *
 * @param matches A list of matches to search into.
 * @param position The position to find.
 */
export declare function findPosition(matches: Match[], position: number): ParticipantSlot;
/**
 * Checks if a participant is involved in a given match.
 *
 * @param match A match.
 * @param participantId ID of a participant.
 */
export declare function isParticipantInMatch(match: MatchResults, participantId: number): boolean;
/**
 * Gets the side where the winner of the given match will go in the next match.
 *
 * @param matchNumber Number of the match.
 */
export declare function getSide(matchNumber: number): Side;
/**
 * Gets the other side of a match.
 *
 * @param side The side that we don't want.
 */
export declare function getOtherSide(side: Side): Side;
/**
 * Checks if a match is started.
 *
 * @param match Partial match results.
 */
export declare function isMatchStarted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed.
 *
 * @param match Partial match results.
 */
export declare function isMatchCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed because of a forfeit.
 *
 * @param match Partial match results.
 */
export declare function isMatchForfeitCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed because of a either a draw or a win.
 *
 * @param match Partial match results.
 */
export declare function isMatchResultCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed because of a draw.
 *
 * @param match Partial match results.
 */
export declare function isMatchDrawCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed because of a win.
 *
 * @param match Partial match results.
 */
export declare function isMatchWinCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match is completed because of at least one BYE.
 *
 * A match "BYE vs. TBD" isn't considered completed yet.
 *
 * @param match Partial match results.
 */
export declare function isMatchByeCompleted(match: Partial<MatchResults>): boolean;
/**
 * Checks if a match's results can't be updated.
 *
 * @param match The match to check.
 */
export declare function isMatchUpdateLocked(match: MatchResults): boolean;
/**
 * Checks if a match's participants can't be updated.
 *
 * @param match The match to check.
 */
export declare function isMatchParticipantLocked(match: MatchResults): boolean;
/**
 * Indicates whether a match has at least one BYE or not.
 *
 * @param match Partial match results.
 */
export declare function hasBye(match: Partial<MatchResults>): boolean;
/**
 * Returns the status of a match based on the opponents of a match.
 *
 * @param opponents The opponents of a match.
 */
export declare function getMatchStatus(opponents: Duel): Status;
/**
 * Returns the status of a match based on the results of a match.
 *
 * @param match Partial match results.
 */
export declare function getMatchStatus(match: Partial<MatchResults>): Status;
/**
 * Updates a match results based on an input.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 * @param inRoundRobin Indicates whether the match is in a round-robin stage.
 */
export declare function setMatchResults(stored: MatchResults, match: Partial<MatchResults>, inRoundRobin: boolean): {
    statusChanged: boolean;
    resultChanged: boolean;
};
/**
 * Resets the results of a match. (status, forfeit, result)
 *
 * @param stored A reference to what will be updated in the storage.
 */
export declare function resetMatchResults(stored: MatchResults): void;
/**
 * Passes user-defined extra fields to the stored match.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 */
export declare function setExtraFields(stored: MatchResults, match: Partial<MatchResults>): void;
/**
 * Gets the id of the opponent at the given side of the given match.
 *
 * @param match The match to get the opponent from.
 * @param side The side where to get the opponent from.
 */
export declare function getOpponentId(match: MatchResults, side: Side): number | null;
/**
 * Gets the origin position of a side of a match.
 *
 * @param match The match.
 * @param side The side.
 */
export declare function getOriginPosition(match: Match, side: Side): number;
/**
 * Returns every loser in a list of matches.
 *
 * @param participants The list of participants.
 * @param matches A list of matches to get losers of.
 */
export declare function getLosers(participants: Participant[], matches: Match[]): Participant[][];
/**
 * Makes final standings based on participants grouped by ranking.
 *
 * @param grouped A list of participants grouped by ranking.
 */
export declare function makeFinalStandings(grouped: Participant[][]): FinalStandingsItem[];
/**
 * Returns the decisive match of a Grand Final.
 *
 * @param type The type of Grand Final.
 * @param matches The matches in the Grand Final.
 */
export declare function getGrandFinalDecisiveMatch(type: GrandFinalType, matches: Match[]): Match;
/**
 * Finds a participant in a list.
 *
 * @param participants The list of participants.
 * @param slot The slot of the participant to find.
 */
export declare function findParticipant(participants: Participant[], slot: ParticipantSlot): Participant;
/**
 * Gets the side the winner of the current match will go to in the next match.
 *
 * @param matchNumber Number of the current match.
 * @param roundNumber Number of the current round.
 * @param roundCount Count of rounds.
 * @param matchLocation Location of the current match.
 */
export declare function getNextSide(matchNumber: number, roundNumber: number, roundCount: number, matchLocation: BracketKind): Side;
/**
 * Gets the side the winner of the current match in loser bracket will go in the next match.
 *
 * @param matchNumber Number of the match.
 * @param nextMatch The next match.
 * @param roundNumber Number of the current round.
 */
export declare function getNextSideLoserBracket(matchNumber: number, nextMatch: Match, roundNumber: number): Side;
export declare type SetNextOpponent = (nextMatch: Match, nextSide: Side, match?: Match, currentSide?: Side) => void;
/**
 * Sets an opponent in the next match he has to go.
 *
 * @param nextMatch A match which follows the current one.
 * @param nextSide The side the opponent will be on in the next match.
 * @param match The current match.
 * @param currentSide The side the opponent is currently on.
 */
export declare function setNextOpponent(nextMatch: Match, nextSide: Side, match?: Match, currentSide?: Side): void;
/**
 * Resets an opponent in the match following the current one.
 *
 * @param nextMatch A match which follows the current one.
 * @param nextSide The side the opponent will be on in the next match.
 */
export declare function resetNextOpponent(nextMatch: Match, nextSide: Side): void;
/**
 * Inverts opponents if requested by the input.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 */
export declare function handleOpponentsInversion(stored: MatchResults, match: Partial<MatchResults>): void;
/**
 * Inverts `opponent1` and `opponent2` in a match.
 *
 * @param match A match to update.
 */
export declare function invertOpponents(match: Partial<MatchResults>): void;
/**
 * Updates the scores of a match.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 * @returns `true` if the status of the match changed, `false` otherwise.
 */
export declare function setScores(stored: MatchResults, match: Partial<MatchResults>): boolean;
/**
 * Completes a match and handles results and forfeits.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 * @param inRoundRobin Indicates whether the match is in a round-robin stage.
 */
export declare function setCompleted(stored: MatchResults, match: Partial<MatchResults>, inRoundRobin: boolean): void;
/**
 * Enforces the symmetry between opponents.
 *
 * Sets an opponent's result to something, based on the result on the other opponent.
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 * @param check A result to check in each opponent.
 * @param change A result to set in each other opponent if `check` is correct.
 * @param inRoundRobin Indicates whether the match is in a round-robin stage.
 */
export declare function setResults(stored: MatchResults, match: Partial<MatchResults>, check: Result, change: Result, inRoundRobin: boolean): void;
/**
 * Sets forfeits for each opponent (if needed).
 *
 * @param stored A reference to what will be updated in the storage.
 * @param match Input of the update.
 */
export declare function setForfeits(stored: MatchResults, match: Partial<MatchResults>): void;
/**
 * Indicates if a seeding is filled with participants' IDs.
 *
 * @param seeding The seeding.
 */
export declare function isSeedingWithIds(seeding: Seeding): boolean;
/**
 * Extracts participants from a seeding, without the BYEs.
 *
 * @param tournamentId ID of the tournament.
 * @param seeding The seeding (no IDs).
 */
export declare function extractParticipantsFromSeeding(tournamentId: number, seeding: Seeding): OmitId<Participant>[];
/**
 * Returns participant slots mapped to the instances stored in the database thanks to their name.
 *
 * @param seeding The seeding.
 * @param database The participants stored in the database.
 * @param positions An optional list of positions (seeds) for a manual ordering.
 */
export declare function mapParticipantsNamesToDatabase(seeding: Seeding, database: Participant[], positions?: number[]): ParticipantSlot[];
/**
 * Returns participant slots mapped to the instances stored in the database thanks to their id.
 *
 * @param seeding The seeding.
 * @param database The participants stored in the database.
 * @param positions An optional list of positions (seeds) for a manual ordering.
 */
export declare function mapParticipantsIdsToDatabase(seeding: Seeding, database: Participant[], positions?: number[]): ParticipantSlot[];
/**
 * Returns participant slots mapped to the instances stored in the database thanks to a property of theirs.
 *
 * @param prop The property to search participants with.
 * @param seeding The seeding.
 * @param database The participants stored in the database.
 * @param positions An optional list of positions (seeds) for a manual ordering.
 */
export declare function mapParticipantsToDatabase(prop: 'id' | 'name', seeding: Seeding, database: Participant[], positions?: number[]): ParticipantSlot[];
/**
 * Converts a list of matches to a seeding.
 *
 * @param matches The input matches.
 */
export declare function convertMatchesToSeeding(matches: Match[]): ParticipantSlot[];
/**
 * Converts a list of slots to an input seeding.
 *
 * @param slots The slots to convert.
 */
export declare function convertSlotsToSeeding(slots: ParticipantSlot[]): Seeding;
/**
 * Sorts the seeding with the BYEs in the correct position.
 *
 * @param slots A list of slots to sort.
 */
export declare function sortSeeding(slots: ParticipantSlot[]): ParticipantSlot[];
/**
 * Returns only the non null elements.
 *
 * @param array The array to process.
 */
export declare function getNonNull<T>(array: Nullable<T>[]): T[];
/**
 * Returns a list of objects which have unique values of a specific key.
 *
 * @param array The array to process.
 * @param key The key to filter by.
 */
export declare function uniqueBy<T>(array: T[], key: (obj: T) => unknown): T[];
/**
 * Makes the transition to a major round for duels of the previous round. The duel count is divided by 2.
 *
 * @param previousDuels The previous duels to transition from.
 */
export declare function transitionToMajor(previousDuels: Duel[]): Duel[];
/**
 * Makes the transition to a minor round for duels of the previous round. The duel count stays the same.
 *
 * @param previousDuels The previous duels to transition from.
 * @param losers Losers from the previous major round.
 * @param method The ordering method for the losers.
 */
export declare function transitionToMinor(previousDuels: Duel[], losers: ParticipantSlot[], method?: SeedOrdering): Duel[];
/**
 * Sets the parent match to a completed status if all its child games are completed.
 *
 * @param parent The partial parent match to update.
 * @param childCount Child count of this parent match.
 * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.
 */
export declare function setParentMatchCompleted(parent: Partial<MatchResults>, childCount: number, inRoundRobin: boolean): void;
/**
 * Returns a parent match results based on its child games scores.
 *
 * @param storedParent The parent match stored in the database.
 * @param scores The scores of the match child games.
 */
export declare function getParentMatchResults(storedParent: Match, scores: Scores): Partial<MatchResults>;
/**
 * Gets the values which need to be updated in a match when it's updated on insertion.
 *
 * @param match The up to date match.
 * @param existing The base match.
 * @param enableByes Whether to use BYEs or TBDs for `null` values in an input seeding.
 */
export declare function getUpdatedMatchResults<T extends MatchResults>(match: T, existing: T, enableByes: boolean): T;
/**
 * Calculates the score of a parent match based on its child games.
 *
 * @param games The child games to process.
 */
export declare function getChildGamesResults(games: MatchGame[]): Scores;
/**
 * Gets the default list of seeds for a round's matches.
 *
 * @param inLoserBracket Whether the match is in the loser bracket.
 * @param roundNumber The number of the current round.
 * @param roundCountLB The count of rounds in loser bracket.
 * @param matchCount The count of matches in the round.
 */
export declare function getSeeds(inLoserBracket: boolean, roundNumber: number, roundCountLB: number, matchCount: number): number[];
/**
 * Gets the number of seeds for a round's matches.
 *
 * @param inLoserBracket Whether the match is in the loser bracket.
 * @param roundNumber The number of the current round.
 * @param roundCountLB The count of rounds in loser bracket.
 * @param matchCount The count of matches in the round.
 */
export declare function getSeedCount(inLoserBracket: boolean, roundNumber: number, roundCountLB: number, matchCount: number): number;
/**
 * Throws if the ordering is not supported on the given round number.
 *
 * @param inLoserBracket Whether the match is in the loser bracket.
 * @param roundNumber The number of the round.
 * @param roundCountLB The count of rounds in loser bracket.
 */
export declare function ensureOrderingSupported(inLoserBracket: boolean, roundNumber: number, roundCountLB: number): void;
/**
 * Indicates whether the ordering is supported in upper bracket, given the round number.
 *
 * @param roundNumber The number of the round.
 */
export declare function isOrderingSupportedUpperBracket(roundNumber: number): boolean;
/**
 * Indicates whether the ordering is supported in loser bracket, given the round number.
 *
 * @param roundNumber The number of the round.
 * @param roundCount The count of rounds.
 */
export declare function isOrderingSupportedLoserBracket(roundNumber: number, roundCount: number): boolean;
/**
 * Returns the number of rounds an upper bracket has given the number of participants in the stage.
 *
 * @param participantCount The number of participants in the stage.
 */
export declare function getUpperBracketRoundCount(participantCount: number): number;
/**
 * Returns the count of round pairs (major & minor) in a loser bracket.
 *
 * @param participantCount The number of participants in the stage.
 */
export declare function getRoundPairCount(participantCount: number): number;
/**
 * Determines whether a double elimination stage is really necessary.
 *
 * If the size is only two (less is impossible), then a lower bracket and a grand final are not necessary.
 *
 * @param participantCount The number of participants in the stage.
 */
export declare function isDoubleEliminationNecessary(participantCount: number): boolean;
/**
 * Returns the real (because of loser ordering) number of a match in a loser bracket.
 *
 * @param participantCount The number of participants in a stage.
 * @param roundNumber Number of the round.
 * @param matchNumber Number of the match.
 * @param method The method used for the round.
 */
export declare function findLoserMatchNumber(participantCount: number, roundNumber: number, matchNumber: number, method?: SeedOrdering): number;
/**
 * Returns the count of matches in a round of a loser bracket.
 *
 * @param participantCount The number of participants in a stage.
 * @param roundNumber Number of the round.
 */
export declare function getLoserRoundMatchCount(participantCount: number, roundNumber: number): number;
/**
 * Returns the count of losers in a round of a loser bracket.
 *
 * @param participantCount The number of participants in a stage.
 * @param roundNumber Number of the round.
 */
export declare function getLoserRoundLoserCount(participantCount: number, roundNumber: number): number;
/**
 * Returns the ordering method of a round of a loser bracket.
 *
 * @param seedOrdering The list of seed orderings.
 * @param roundNumber Number of the round.
 */
export declare function getLoserOrdering(seedOrdering: SeedOrdering[], roundNumber: number): SeedOrdering | undefined;
/**
 * Returns the number of rounds a lower bracket has given the number of participants in a double elimination stage.
 *
 * @param participantCount The number of participants in the stage.
 */
export declare function getLowerBracketRoundCount(participantCount: number): number;
/**
 * Returns the match number of the corresponding match in the next round by dividing by two.
 *
 * @param matchNumber The current match number.
 */
export declare function getDiagonalMatchNumber(matchNumber: number): number;
/**
 * Returns the nearest power of two **greater than** or equal to the given number.
 *
 * @param input The input number.
 */
export declare function getNearestPowerOfTwo(input: number): number;
/**
 * Returns the minimum score a participant must have to win a Best Of X series match.
 *
 * @param x The count of child games in the series.
 */
export declare function minScoreToWinBestOfX(x: number): number;
/**
 * Checks if a stage is a round-robin stage.
 *
 * @param stage The stage to check.
 */
export declare function isRoundRobin(stage: Stage): boolean;
/**
 * Throws if a stage is round-robin.
 *
 * @param stage The stage to check.
 */
export declare function ensureNotRoundRobin(stage: Stage): void;
/**
 * Checks if a round is completed based on its matches.
 *
 * @param roundMatches Matches of the round.
 */
export declare function isRoundCompleted(roundMatches: Match[]): boolean;
/**
 * Checks if a group is a winner bracket.
 *
 * It's not always the opposite of `inLoserBracket()`: it could be the only bracket of a single elimination stage.
 *
 * @param stageType Type of the stage.
 * @param groupNumber Number of the group.
 */
export declare function isWinnerBracket(stageType: StageType, groupNumber: number): boolean;
/**
 * Checks if a group is a loser bracket.
 *
 * @param stageType Type of the stage.
 * @param groupNumber Number of the group.
 */
export declare function isLoserBracket(stageType: StageType, groupNumber: number): boolean;
/**
 * Checks if a group is a final group (consolation final or grand final).
 *
 * @param stageType Type of the stage.
 * @param groupNumber Number of the group.
 */
export declare function isFinalGroup(stageType: StageType, groupNumber: number): boolean;
/**
 * Returns the type of group the match is located into.
 *
 * @param stageType Type of the stage.
 * @param groupNumber Number of the group.
 */
export declare function getMatchLocation(stageType: StageType, groupNumber: number): BracketKind;
//# sourceMappingURL=helpers.d.ts.map