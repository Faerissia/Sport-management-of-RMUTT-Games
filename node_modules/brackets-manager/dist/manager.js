"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BracketsManager = void 0;
const create_1 = require("./create");
const get_1 = require("./get");
const update_1 = require("./update");
const delete_1 = require("./delete");
const find_1 = require("./find");
const reset_1 = require("./reset");
const helpers = require("./helpers");
/**
 * A class to handle tournament management at those levels: `stage`, `group`, `round`, `match` and `match_game`.
 */
class BracketsManager {
    /**
     * Creates an instance of BracketsManager, which will handle all the stuff from the library.
     *
     * @param storageInterface An implementation of CrudInterface.
     */
    constructor(storageInterface) {
        const storage = storageInterface;
        storage.selectFirst = async (table, filter) => {
            const results = await this.storage.select(table, filter);
            if (!results || results.length === 0)
                return null;
            return results[0];
        };
        storage.selectLast = async (table, filter) => {
            const results = await this.storage.select(table, filter);
            if (!results || results.length === 0)
                return null;
            return results[results.length - 1];
        };
        this.storage = storage;
        this.get = new get_1.Get(this.storage);
        this.update = new update_1.Update(this.storage);
        this.delete = new delete_1.Delete(this.storage);
        this.find = new find_1.Find(this.storage);
        this.reset = new reset_1.Reset(this.storage);
    }
    /**
     * Creates a stage for an existing tournament. The tournament won't be created.
     *
     * @param stage A stage to create.
     */
    async create(stage) {
        return create_1.create.call(this, stage);
    }
    /**
     * Imports data in the database.
     *
     * @param data Data to import.
     * @param normalizeIds Enable ID normalization: all IDs (and references to them) are remapped to consecutive IDs starting from 0.
     */
    async import(data, normalizeIds = false) {
        if (normalizeIds)
            data = helpers.normalizeIds(data);
        if (!await this.storage.delete('participant'))
            throw Error('Could not empty the participant table.');
        if (!await this.storage.insert('participant', data.participant))
            throw Error('Could not import participants.');
        if (!await this.storage.delete('stage'))
            throw Error('Could not empty the stage table.');
        if (!await this.storage.insert('stage', data.stage))
            throw Error('Could not import stages.');
        if (!await this.storage.delete('group'))
            throw Error('Could not empty the group table.');
        if (!await this.storage.insert('group', data.group))
            throw Error('Could not import groups.');
        if (!await this.storage.delete('round'))
            throw Error('Could not empty the round table.');
        if (!await this.storage.insert('round', data.round))
            throw Error('Could not import rounds.');
        if (!await this.storage.delete('match'))
            throw Error('Could not empty the match table.');
        if (!await this.storage.insert('match', data.match))
            throw Error('Could not import matches.');
        if (!await this.storage.delete('match_game'))
            throw Error('Could not empty the match_game table.');
        if (!await this.storage.insert('match_game', data.match_game))
            throw Error('Could not import match games.');
    }
    /**
     * Exports data from the database.
     */
    async export() {
        const participants = await this.storage.select('participant');
        if (!participants)
            throw Error('Error getting participants.');
        const stages = await this.storage.select('stage');
        if (!stages)
            throw Error('Error getting stages.');
        const groups = await this.storage.select('group');
        if (!groups)
            throw Error('Error getting groups.');
        const rounds = await this.storage.select('round');
        if (!rounds)
            throw Error('Error getting rounds.');
        const matches = await this.storage.select('match');
        if (!matches)
            throw Error('Error getting matches.');
        const matchGames = await this.get.matchGames(matches);
        return {
            participant: participants,
            stage: stages,
            group: groups,
            round: rounds,
            match: matches,
            match_game: matchGames,
        };
    }
}
exports.BracketsManager = BracketsManager;
//# sourceMappingURL=manager.js.map