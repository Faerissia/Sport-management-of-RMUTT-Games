"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryDatabase = void 0;
const rfdc = require("rfdc");
const clone = rfdc();
class InMemoryDatabase {
    data = {
        participant: [],
        stage: [],
        group: [],
        round: [],
        match: [],
        match_game: [],
    };
    /**
     * @param data "import" data from external
     */
    setData(data) {
        this.data = data;
    }
    /**
     * @param partial Filter
     */
    makeFilter(partial) {
        return (entry) => {
            let result = true;
            for (const key of Object.keys(partial))
                result = result && entry[key] === partial[key];
            return result;
        };
    }
    /**
     * Clearing all of the data
     */
    reset() {
        this.data = {
            participant: [],
            stage: [],
            group: [],
            round: [],
            match: [],
            match_game: [],
        };
    }
    /**
     * Implementation of insert
     *
     * @param table Where to insert.
     * @param values What to insert.
     */
    insert(table, values) {
        let id = this.data[table].length > 0
            ? (Math.max(...this.data[table].map(d => d.id)) + 1)
            : 0;
        if (!Array.isArray(values)) {
            try {
                // @ts-ignore
                this.data[table].push({ id, ...values });
            }
            catch (error) {
                return new Promise((resolve) => {
                    resolve(-1);
                });
            }
            return new Promise((resolve) => {
                resolve(id);
            });
        }
        try {
            values.map((object) => {
                // @ts-ignore
                this.data[table].push({ id: id++, ...object });
            });
        }
        catch (error) {
            return new Promise((resolve) => {
                resolve(false);
            });
        }
        return new Promise((resolve) => {
            resolve(true);
        });
    }
    /**
     * @param table Where to get from.
     * @param arg Arg.
     */
    select(table, arg) {
        try {
            if (arg === undefined) {
                return new Promise((resolve) => {
                    // @ts-ignore
                    resolve(this.data[table].map(clone));
                });
            }
            if (typeof arg === 'number') {
                return new Promise((resolve) => {
                    // @ts-ignore
                    resolve(clone(this.data[table].find(d => d.id === arg)));
                });
            }
            return new Promise((resolve) => {
                // @ts-ignore
                resolve(this.data[table].filter(this.makeFilter(arg)).map(clone));
            });
        }
        catch (error) {
            return new Promise((resolve) => {
                resolve(null);
            });
        }
    }
    /**
     * Updates data in a table.
     *
     * @param table Where to update.
     * @param arg
     * @param value How to update.
     */
    update(table, arg, value) {
        if (typeof arg === 'number') {
            try {
                // @ts-ignore
                this.data[table][arg] = value;
                return new Promise((resolve) => {
                    resolve(true);
                });
            }
            catch (error) {
                return new Promise((resolve) => {
                    resolve(false);
                });
            }
        }
        // @ts-ignore
        const values = this.data[table].filter(this.makeFilter(arg));
        if (!values) {
            return new Promise((resolve) => {
                resolve(false);
            });
        }
        values.forEach((v) => {
            const existing = this.data[table][v.id];
            for (const key in value) {
                // @ts-ignore
                if (existing[key] && typeof existing[key] === 'object' && typeof value[key] === 'object') {
                    // @ts-ignore
                    Object.assign(existing[key], value[key]); // For opponent objects, this does a deep merge of level 2.
                }
                else {
                    // @ts-ignore
                    existing[key] = value[key]; // Otherwise, do a simple value assignment.
                }
            }
            this.data[table][v.id] = existing;
        });
        return new Promise((resolve) => {
            resolve(true);
        });
    }
    /**
     * Delete data in a table, based on a filter.
     *
     * @param table Where to delete in.
     * @param filter An object to filter data.
     */
    delete(table, filter) {
        const values = this.data[table];
        if (!values) {
            return new Promise((resolve) => {
                resolve(false);
            });
        }
        if (!filter) {
            this.data[table] = [];
            return new Promise((resolve) => {
                resolve(true);
            });
        }
        const predicate = this.makeFilter(filter);
        const negativeFilter = (value) => !predicate(value);
        // @ts-ignore
        this.data[table] = values.filter(negativeFilter);
        return new Promise((resolve) => {
            resolve(true);
        });
    }
}
exports.InMemoryDatabase = InMemoryDatabase;
